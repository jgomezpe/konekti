{"html":"<canvas id='·id·Canvas' style='position:absolute; top:0; left:0; width:100%; height:100%; border:1px solid #d3d3d3'></canvas>\n","js":"class CanvasEditor extends KonektiEditor{\n\tconstructor(dictionary){\n\t\tsuper(dictionary)\n\t\tvar id = this.id\n\t\tthis.gui = this.vc('Canvas')\n\t\tthis.custom = {}\n\t\tif( typeof dictionary.custom != 'undefined' ) this.custom_commands( dictionary.custom )\n\t\tif( typeof dictionary.commands !== 'undefined' ) this.commands = dictionary.commands\n\t\telse this.commands = {}\n\t\tthis.redraw()\n\t}\n\t\n\tcustom_commands( custom ){\n\t    if( typeof custom !== 'undefined' ){\n\t        for( var i=0; i<custom.commands.length; i++ ){\n\t            this.custom[custom.commands[i].command] = custom.commands[i]\n\t        }\n\t    }\n\t}\n\n\tgetContext(){ \n//\t\tthis.gui = Konekti.util.vc('canvas'+this.id)\n\t\treturn this.gui.getContext('2d') \n\t}\n\n\tclear(){ this.getContext().strokeRect(0,0,this.gui.width,this.gui.height) }\n\n\tredraw(){\n\t\tthis.resize()\n\t\tthis.draw(this.commands) \n\t}\n\t\n\tinner_scale( obj, sx, sy ){\n\t    var c = this.copy(obj)\n\t\tif( typeof obj.commands !== 'undefined' ){\n\t\t    var commands = []\n\t\t\tfor(var i=0; i<obj.commands.length; i++ ) \n                commands[i] = this.inner_scale(obj.commands[i],sx,sy)\n\t\t\tc.commands = commands\n\t\t}\n\t\tif( typeof obj.x !== 'undefined' ){\n    \t    if( Array.isArray(obj.x) ){\n    \t        var nx = []\n    \t        var ny = []\n    \t        for(var i=0; i<obj.x.length; i++){\n    \t            nx.push(obj.x[i]*sx)\n    \t            ny.push(obj.y[i]*sy)\n    \t        }\n    \t        c.x = nx\n    \t        c.y = ny\n    \t    }else{\n                c.x = obj.x * sx\n                c.y = obj.y * sy\n    \t    }\n\t\t}    \n\t\treturn c\n\t}\n\t\n\tscale( obj ){\n\t    obj.command = 'compound'\n\t    var sx = obj.x\n\t    var sy = obj.y\n\t    var nobj = this.inner_scale(obj,sx,sy)\n\t    obj.x = sx\n\t    obj.y = sy\n\t    obj.command = 'scale'\n\t    return nobj\n\t}\n\n\tinner_translate( obj, dx, dy ){\n\t    var c = this.copy(obj)\n\t\tif( typeof obj.commands !== 'undefined' ){\n\t\t    var commands = []\n\t\t\tfor(var i=0; i<obj.commands.length; i++ ) \n                commands[i] = this.inner_translate(obj.commands[i],dx,dy)\n\t\t\tc.commands = commands\n\t\t}\n\t\tif( typeof obj.x !== 'undefined' ){\n            if( Array.isArray(obj.x) ){\n                var nx = []\n                var ny = []\n                for(var i=0; i<obj.x.length; i++){\n                    nx.push(obj.x[i]+dx)\n                    ny.push(obj.y[i]+dy)\n                }    \n                c.x = nx\n                c.y = ny\n            }else{\n                c.x = obj.x + dx\n                c.y = obj.y + dy\n            }\n\t\t}    \n\t\treturn c\n\t}\n\t\n\ttranslate( obj ){\n        obj.command = 'compound'\n        var x = obj.x\n        var y = obj.y\n        var nobj = this.inner_translate(obj,x,y)\n        obj.x = x\n        obj.y = y\n        obj.command = 'translate'\n        return nobj\n\t}\n\n\tangle( x1, y1, x2, y2 ){\n\t\tvar a = (x2-x1) \n\t\tvar b = (y2-y1)\n\t\tvar r = Math.sqrt(a*a+b*b)\n\t\tif( r>1e-6 ){\n\t\t\tvar alpha = Math.acos(a/r)\n\t\t\tif( b<0 ) alpha = 2.0*Math.PI - alpha\n\t\t\treturn alpha\n\t\t}else return 0.0\n\t}\n\t\n\trotate_point( cx, cy, px, py, angle ){\n\t\tvar alpha = this.angle( cx, cy, px, py ) + angle\n\t\tif( alpha>1e-6 ){\n\t\t\tvar a = (px-cx)\n            var b = (py-cy)\n\t\t\tvar r = Math.sqrt(a*a+b*b)\n\t\t\treturn [cx + r*Math.cos(alpha), cy + r*Math.sin(alpha)]\n\t\t}else return [px,py]\t\t\t\n\t}\n\t\n\tinner_rotate( obj, cx, cy, angle ){\n\t    var c = this.copy(obj)\n\t\tif( typeof obj.commands !== 'undefined' ){\n\t\t    var commands = []\n\t\t\tfor(var i=0; i<obj.commands.length; i++ ) \n                commands[i] = this.inner_rotate(obj.commands[i],cx,cy,angle)\n\t\t\tc.commands = commands\n\t\t}\n\t\tif( obj.command == 'image' ) c.r = obj.r + angle\n\t\telse{\n\t\t    var p\n    \t\tif( typeof obj.x !== 'undefined' ){\n                if( Array.isArray(obj.x) ){\n                    var nx = []\n                    var ny = []\n                    for(var i=0; i<obj.x.length; i++){\n                        p = this.rotate_point( cx, cy, obj.x[i], obj.y[i], angle )\n                        nx.push(p[0])\n                        ny.push(p[1])\n                    }    \n                    c.x = nx\n                    c.y = ny\n                }else{\n                    p = this.rotate_point( cx, cy, obj.x, obj.y, angle )\n                    c.x = p[0]\n                    c.y = p[1]\n                }\n    \t\t}    \n\t\t}\n\t\treturn c\n\t}\n\t\n\trotate( obj ){\n        obj.command = 'compound'\n        var x = obj.x\n        var y = obj.y\n        var a = obj.r\n        var nobj = this.inner_rotate(obj,x,y,a)\n        obj.x = x\n        obj.y = y\n        obj.r = a\n        obj.command = 'rotate'\n        return nobj\n\t}\n\t\n\tfit( obj ){\n        var c = this.copy(obj)\n        c.command = 'scale'\n        var x = obj.x\n        var y = obj.y\n        var keepAspectRatio = obj.r\n\t\tvar w = this.gui.offsetWidth\n\t\tvar h = this.gui.offsetHeight\n        if(keepAspectRatio) {\n\t\t    var s\n            if( w*x < h*y ) s = w*x\n            else s = h*y\n            x = s\n            y = s\n        }else {\n            x *= w\n            y *= h\n        }\n        c.x = x\n        c.y = y\n        c.commands = obj.commands\n        return this.scale(c)\n\t}\n\n\tresize(){\n\t\tvar used = this.commands\n\t\tvar ctx = this.getContext()\n\t\tctx.canvas.width = this.gui.offsetWidth\n\t\tctx.canvas.height = this.gui.offsetHeight\n\t}\n\n\t// Drawing functions \n\timage(obj){\n\t\tvar img = Konekti.util.vc(obj.id)\n\t\tif( img==undefined || img==null ){\n\t\t\timg = component.new('img', obj.id)\n\t\t\timg.src = obj.src\n\t\t\timg.alt = 'Undefined'\n\t\t}   \n     \n\t\tvar rotate\n\t\tif( obj.rotate!=undefined && obj.rotate!=null && obj.rotate!=0 ) rotate = obj.rotate\n\t\telse rotate=0\n\n\t\tvar x = obj.x \n\t\tvar y = obj.y \n\t\tvar width = obj.width \n\t\tvar height = obj.height\n\n\t\tvar ctx = this.getContext()\n\t     \n\t\tif( rotate!=0 ){\n\t\t\tctx.save()\n\t\t\tvar rx = x + width/2\n\t\t\tvar ry = y + height/2\n\t\t\tctx.translate(rx, ry)\n\t\t\tctx.rotate(rotate * Math.PI/2)\n\t\t\tctx.drawImage(img, -width/2, -height/2, width, height)\n\t\t\tctx.restore()\n\t\t}else ctx.drawImage(img, x, y, width, height)\n\t}\n\n\tcompound(obj){\n\t\tvar objs = obj.commands\n\t\tfor( var i=0; i<objs.length; i++ ) this[objs[i].command](objs[i])\n\t}\n\n\tbeginPath(obj){ this.getContext().beginPath() }\n\n\tclosePath(obj){ this.getContext().closePath() }\n\n\tmoveTo(obj){\n\t\tvar ctx = this.getContext()\n\t\tvar x = obj.x \n\t\tvar y = obj.y\n\t\tctx.moveTo(x,y)\n\t}\n\n\tlineTo(obj){\n\t\tvar ctx = this.getContext()\n\t\tvar x = obj.x\n\t\tvar y = obj.y\n\t\tctx.lineTo(x,y)\n\t}\n\n\tquadTo(obj){\n\t\tvar ctx = this.getContext()\n\t\tvar cp1x = obj.x[0] \n\t\tvar cp1y = obj.y[0]\n\t\tvar x = obj.x[1]\n\t\tvar y = obj.y[1]\n\t\tctx.quadraticCurveTo(cp1x, cp1y, x, y) \n\t}\n\n\tcurveTo(obj){\n\t\tvar ctx = this.getContext()\n\t\tvar cp1x = obj.x[0] \n\t\tvar cp1y = obj.y[0]\n\t\tvar cp2x = obj.x[1]\n\t\tvar cp2y = obj.y[1]\n\t\tvar x = obj.x[2]\n\t\tvar y = obj.y[2]\n\t\tctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\n\t}\n\n\tline(obj){\n\t\tthis.beginPath(obj)\n\t\tthis.moveTo({x:obj.x[0],y:obj.y[0]})\n\t\tthis.lineTo({x:obj.x[1],y:obj.y[1]})\n\t\tthis.stroke(obj)\n\t}\n\n\tpoly(obj){\n\t\tthis.beginPath(obj)\n\t\tvar px = obj.x\n\t\tvar py = obj.y\n\t\tthis.moveTo({x:px[0],y:py[0]})\n\t\tfor( var i=1; i<px.length; i++) this.lineTo({x:px[i],y:py[i]})\n\t}\n\n\tpolyline(obj){\n\t\tthis.poly(obj)\n\t\tthis.stroke(obj)\n\t}\n\n\tpolygon(obj){\n\t\tthis.poly(obj)\n\t\tthis.fill(obj)\n\t}\n\t\n    rgba( obj ){ return \"rgba(\"+obj.red+\",\"+obj.green+\",\"+obj.blue+\",\"+obj.alpha+\")\"; }\n\n\tstyle(obj){\n\t\tif( obj.color != null )\treturn this.rgba(obj.color)\n\t\tif( obj.startcolor == null ) return null\n\t\tvar c1 = this.rgba(obj.startcolor)\n\t\tvar c2 = this.rgba(obj.endcolor)\n\t\tvar ctx = this.getContext()\n\t\tvar gradient\n\t\tif( obj.r != null ){\n\t\t\tvar r = obj.r\n\t\t\tvar x = obj.x \n\t\t\tvar y = obj.y\n\t\t\tgradient = ctx.createRadialGradient(x, y, 1, x, y, r)\n\t\t}else{\n\t\t\tvar x1 = obj.x[0] \n\t\t\tvar y1 = obj.y[0] \n\t\t\tvar x2 = obj.x[1] \n\t\t\tvar y2 = obj.y[1] \n\t\t\tgradient = ctx.createLinearGradient(x1, y1, x2, y2)\n\t\t}\n\t\tgradient.addColorStop(\"0\", c1)\n\t\tgradient.addColorStop(\"1\", c2)\n\t\treturn gradient\n\t}\n\n\tstrokeStyle(obj){\n\t\tvar ctx = this.getContext() \n\t\tctx.strokeStyle = this.style(obj)\n\t\tif( obj.lineWidth != null ) ctx.lineWidth = obj.lineWidth\n\t}\n\n\tfillStyle(obj){\n\t\tvar ctx = this.getContext()\n\t\tctx.fillStyle = this.style(obj)\n\t}\n\n\tstroke(obj){ this.getContext().stroke() }\n\n\tfill(obj){\n\t\tvar ctx = this.getContext()\n\t\tctx.closePath()\n\t\tctx.fill()\n\t}\n\t\n\tcopy(c){\n\t    var cc = {}\n\t    for( var x in c ){\n\t        cc[x] = c[x]\n\t    }\n\t    return cc \n\t}\n\n\tinit_command( c ) {\n\t    if(typeof c.command === 'undefined') return c\n\t    var cc = this.custom[c.command]\n\t    if( typeof cc !== 'undefined' ) {\n\t\t    c = this.copy(cc)\n\t\t    c.command = 'compound'\n\t    }\n\n\t    if(typeof c.commands !=='undefined') {\n\t        c = this.copy(c)\n\t        var obj = []\n\t        for(var i=0; i<c.commands.length; i++)\n                obj.push(this.init_command(c.commands[i]))\n            c.commands = obj\n\t    }\n\t    \n\t    if(c.command === 'translate' )\treturn this.translate(c)\n\t    if(c.command === 'rotate' )\treturn this.rotate(c)\n\t    if(c.command === 'scale' )\treturn this.scale(c)\n\t    if(c.command === 'fit' )\treturn this.fit(c)\n\t    return c\n\t}\n\n\tdraw(obj){\n\t\tobj = this.init_command(obj)\n\t\tvar type = obj.command\n\t\tif( type != null ) this[type](obj)\n\t}\n\n\tgetText(){ return JSON.stringify(commands) }\n\n\tsetText(txt){ \n\t\tthis.commands = JSON.parse(txt)\n\t\tthis.redraw()\n\t}\n}\n\n// Canvas functions\nKonekti.plugin.canvas.client = {}\n\nKonekti.plugin.canvas.resize = function () {\n\tvar canvas = Konekti.plugin.canvas\n\tfor (var cc in canvas.client){\n\t\tcanvas.client[cc].redraw()\n\t}\n}\n\t\nKonekti.plugin.canvas.connect = function ( dictionary ){\n\tthis.client[dictionary.id] = new CanvasEditor( dictionary)\n} \n\t\nwindow.addEventListener(\"resize\", Konekti.plugin.canvas.resize);","copyright":"Copyright (c) 2019 by Jonatan Gomez-Perdomo. All rights reserved. See <A HREF='https://github.com/jgomezpe/konekti'>License</A>."}